#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, select

class Router:

    relations = {}
    sockets = {}
    ports = {}
    routingTable = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
    
    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def addRoutingEntry(self, network, netmask, ASPath, peer, localpref, selfOrigin, origin):
        self.routingTable.append({
            'network': network, 
            'netmask': netmask, 
            'ASPath': ASPath,
            'peer' : peer,
            'localpref' : localpref,
            'selfOrigin' : selfOrigin,
            'origin' : origin})

        print('current routing table--------------')
        print(self.routingTable)
        print('relations-------------------')
        print(self.relations)
    
    def sendUpdates(self, obj, src):

        print('updte msg-----------------------------------')
        print(obj)

        del obj['localpref']
        del obj['origin']
        del obj['selfOrigin']
        obj['ASPath'] = [self.asn] + obj['ASPath']
        
        print('after modifying-----------------------------------')
        print(obj)

        match self.relations[src]:
            case 'cust':
                # send to all neighbors
                for neighbor in self.sockets.keys():
                    if neighbor == src:
                        # don't send the update back to itself
                        continue
                    print(f'!!!!!!!!!!!!!!!!!!!!!!!sending update to neighbor: {neighbor}')
                    print(neighbor)
                    self.send(neighbor, json.dumps({
                        'type': 'update', 
                        'src': self.our_addr(neighbor), 
                        'dst': neighbor, 
                        'msg': obj}))
            case 'prov' | 'peer':
                # send to only customers
                pass

    def ipToBinStr(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        binquads = []
        for quad in quads:
            binquads.append(str(bin(quad)))
            binquads[-1] = binquads[-1][2:]
            zerosNeeded = 8 - len(binquads[-1])
            for _ in range(zerosNeeded):
                binquads[-1] = '0' + binquads[-1]
        return ''.join(binquads)

    def matches(self, destIp, network, netmask):
        # https://stackoverflow.com/questions/38085571/how-use-netaddr-to-convert-subnet-mask-to-cidr-in-python
        netmaskBits = sum(bin(int(x)).count('1') for x in netmask.split('.'))
        return netmaskBits if self.ipToBinStr(destIp)[:netmaskBits] == self.ipToBinStr(network)[:netmaskBits] else 0

    def getBestMatch(self, ip):
        bestMatch = {}
        bestMatchLen = 0

        for entry in self.routingTable:
            matchLen = self.matches(ip, entry['network'], entry['netmask'])
            if matchLen > bestMatchLen:
                bestMatchLen = matchLen
                bestMatch = entry
        return bestMatch if bestMatchLen > 0 else None

    def getRouterFromIp(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        quads[3] = int(str(quads[3])[0])
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def handleDataMsg(self, obj):
        print('data obj--------------------------')
        print(obj)
        match = self.getBestMatch(obj['dst'])
        if match is None:
            pass
            # TODO send a no route message back
        else:
            # ensure legality\
            srcRouter = self.getRouterFromIp(obj['src'])
            dstRouter = self.getRouterFromIp(obj['dst'])
            print(self.relations)

            # TODO figure out how to derive source/dest router from source/dest ips so we can ensure legality
            if True: #self.relations[srcRouter] == 'cust' or self.relations[dstRouter] == 'cust':
                print('i\'m sending data woooooooooooooooooo')
                self.send(match['peer'], json.dumps(obj))
            else:
                pass
                # not making money, so drop!
                # TODO send a no route message back
    
    def handleUpdateMsg(self, obj):
        print('?????????????????? recieved an update from a router')
        # 1 TODO save a copy
        # 2 - add to routing table
        self.addRoutingEntry(obj['msg']['network'], obj['msg']['netmask'], obj['msg']['ASPath'], 
        obj['src'], obj['msg']['localpref'], obj['msg']['selfOrigin'], obj['msg']['origin'])
        # 3 - send copies to approproate neighbors
        self.sendUpdates(obj['msg'], obj['src'])

    def handleDumpMsg(self, obj):
        print('dump msg: [[[[[[[[[[[[[[]]]]]]]]]]]]]]')
        print(obj)
        self.send(obj['src'], json.dumps({
            'type': 'table',
            'src': obj['dst'],
            'dst': obj['src'],
            'msg': self.routingTable}))

    def handleMsg(self, obj):
        print('handling msg: ')
        print(obj)
        match obj['type']:
            case 'update':
                self.handleUpdateMsg(obj)
            case 'data':
                self.handleDataMsg(obj)
            case 'dump':
                self.handleDumpMsg(obj)
    
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                obj = json.loads(msg)
                print(obj)
                self.handleMsg(obj)
                #print("Received message '%s' from %s" % (msg, srcif))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()