#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, select, copy

class Router:

    relations = {}
    sockets = {}
    ports = {}
    routingTable = []
    copies = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
    
    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def adjacent(self, network1, network2):
        if network1['netmask'] != network2['netmask']:
            return False
        
        netmaskBits = self.getNetmaskBits(network1['netmask'])

        network1str = self.ipToBinStr(network1['network'])
        network2str = self.ipToBinStr(network2['network'])

        return (network1str[:netmaskBits-1] == network2str[:netmaskBits-1]
                and network1str[netmaskBits-1] != network2str[netmaskBits-1])

    def canBeAggregated(self, network1, network2):
        return (self.adjacent(network1, network2) and
                network1['peer'] == network2['peer'] and
                network1['localpref'] == network2['localpref'] and
                network1['origin'] == network2['origin'] and
                network1['ASPath'] == network2['ASPath'] and
                network1['selfOrigin'] == network2['selfOrigin'])

    def aggregateEntries(self, network1):

        netmaskLen = self.getNetmaskBits(network1['netmask'])
        newNetworkStr = self.ipToBinStr(network1['network'])[:netmaskLen - 1].ljust(32, '0')
        newNetMaskBits = netmaskLen - 1

        quads = [str(int(newNetworkStr[i:i+8], 2)) for i in range(0, len(newNetworkStr), 8)]
        newNetwork = '.'.join(quads)

        newNetMaskStr = ('1' * newNetMaskBits).ljust(32, '0')

        maskQuads = [str(int(newNetMaskStr[i:i+8], 2)) for i in range(0, len(newNetMaskStr), 8)]
        newNetmask = '.'.join(maskQuads)
        
        return {'network': newNetwork,
                'netmask': newNetmask,
                'peer': network1['peer'],
                'origin': network1['origin'],
                'selfOrigin': network1['selfOrigin'],
                'ASPath': network1['ASPath'],
                'localpref': network1['localpref']}

    def performAggregation(self):
        for entry1 in self.routingTable:
            for entry2 in self.routingTable:
                if entry1 != entry2:
                    if self.canBeAggregated(entry1, entry2):
                        self.routingTable.remove(entry1)
                        self.routingTable.remove(entry2)
                        self.routingTable.append(self.aggregateEntries(entry1))
    
    def sendUpdates(self, obj, src):

        del obj['localpref']
        del obj['origin']
        del obj['selfOrigin']
        obj['ASPath'] = [self.asn] + obj['ASPath']
        
        for neighbor in self.sockets.keys():
            if neighbor == src:
                # don't send back to itself
                continue
            if self.relations[src] == 'cust' or self.relations[neighbor] == 'cust':
                self.send(neighbor, json.dumps({
                            'type': 'update',
                            'src': self.our_addr(neighbor),
                            'dst': neighbor,
                            'msg': obj}))

    # converts '127.0.0.1' to '01111111000000000000000000000001', for example
    def ipToBinStr(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        binquads = [str(bin(quad))[2:].rjust(8, '0') for quad in quads]
        return ''.join(binquads)

    def getNetmaskBits(self, netmask):
        return sum(bin(int(x)).count('1') for x in netmask.split('.'))

    # returns the length of the prefix match, or 0 if they don't match
    def matches(self, destIp, network, netmask):
        # https://stackoverflow.com/questions/38085571/how-use-netaddr-to-convert-subnet-mask-to-cidr-in-python
        netmaskBits = self.getNetmaskBits(netmask)
        return netmaskBits if self.ipToBinStr(destIp)[:netmaskBits] == self.ipToBinStr(network)[:netmaskBits] else None

    # TODO make this support the other tie-breaking rules
    def getBestMatch(self, ip):
        
        entryMatches = []

        for entry in self.routingTable:
            matchlen = self.matches(ip, entry['network'], entry['netmask'])
            if matchlen is not None:
                entryMatches.append((entry, matchlen))

        if len(entryMatches) == 0:
            return None

        # filter dictionary such that it only contains entries with the maximum match length
        longestPrefMatch = max([v[1] for v in entryMatches])
        entryMatches = [v[0] for v in entryMatches if v[1] == longestPrefMatch]

        if len(entryMatches) == 1:
            return entryMatches[0]['peer']
        else:
            maxLocalPref = max([v['localpref'] for v in entryMatches])
            entryMatches = [v for v in entryMatches if v['localpref'] == maxLocalPref]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            tempEntryMatches = [v for v in entryMatches if v['selfOrigin'] == True]
            if len(tempEntryMatches) > 0:
                entryMatches = tempEntryMatches
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            shortestASPath = min([len(v['ASPath']) for v in entryMatches])
            entryMatches = [v for v in entryMatches if len(v['ASPath']) == shortestASPath]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            originWeights = {'IGP':2, 'EGP':1, 'UNK':0}
            bestOriginWeight = max([originWeights[v['origin']] for v in entryMatches])
            entryMatches = [v for v in entryMatches if originWeights[v['origin']] == bestOriginWeight]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            return min([v['peer'] for v in entryMatches])

    # don't know if this actually works this way
    def getRouterFromIp(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        quads[3] = int(str(quads[3])[0])
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def sendNoRoute(self, src, dst):
        self.send(dst, json.dumps({
            'type': 'no route',
            'src': src,
            'dst': dst,
            'msg': {}}))

    def handleDataMsg(self, obj, src):
    
        peer = self.getBestMatch(obj['dst'])
        if peer is None:
            self.sendNoRoute(self.our_addr(src), self.getBestMatch(obj['src']))
        else:
            dstRouter = self.getBestMatch(obj['dst'])
            # determine compliance
            if (self.relations[src] == 'cust') or (dstRouter and self.relations[dstRouter] == 'cust'):
                self.send(peer, json.dumps(obj))
            else:
                self.sendNoRoute(self.our_addr(src), self.getBestMatch(obj['src']))
    
    def addRoutingEntry(self, obj):
        self.routingTable.append({
            'network': obj['msg']['network'], 
            'netmask': obj['msg']['netmask'], 
            'ASPath': obj['msg']['ASPath'],
            'peer' : obj['src'],
            'localpref' : obj['msg']['localpref'],
            'selfOrigin' : obj['msg']['selfOrigin'],
            'origin' : obj['msg']['origin']})

    def handleUpdateMsg(self, obj):
        # 2 - add to routing table
        self.addRoutingEntry(obj)
        # 3 - send copies to approproate neighbors
        self.sendUpdates(obj['msg'], obj['src'])

    def handleDumpMsg(self, obj):
        self.send(obj['src'], json.dumps({
            'type': 'table',
            'src': obj['dst'],
            'dst': obj['src'],
            'msg': self.routingTable}))

    def delEntry(self, obj):
        for entryToDel in obj['msg']:
            for entry in self.routingTable:
                if (entryToDel['network'] == entry['network']
                    and entryToDel['netmask'] == entry['netmask']
                        and entry['peer'] == obj['src']):
                    self.routingTable.remove(entry)

    def handleWithdrawMsg(self, obj):
        self.delEntry(obj)

        for neighbor in self.sockets.keys():
            if neighbor == obj['src']:
                # don't send back to itself
                continue
            if self.relations[obj['src']] == 'cust' or self.relations[neighbor] == 'cust':
                self.send(neighbor, json.dumps({
                            'type': 'withdraw',
                            'src': self.our_addr(neighbor),
                            'dst': neighbor,
                            'msg': obj['msg']}))

    def rebuildTable(self):
        for copy in self.copies:
            if copy['type'] == 'update':
                self.addRoutingEntry(copy)
            else:
                self.delEntry(copy)

    def performDisaggregation(self):
        self.routingTable = []
        self.rebuildTable()

    def handleMsg(self, obj, src):
        if obj['type'] == 'update':
            self.copies.append(copy.deepcopy(obj))
            self.handleUpdateMsg(obj)
            self.performAggregation()
        elif obj['type'] == 'data':
            self.handleDataMsg(obj, src)
        elif obj['type'] == 'dump':
            self.handleDumpMsg(obj)
        elif obj['type'] == 'withdraw':
            self.copies.append(copy.deepcopy(obj))
            self.performDisaggregation()
            self.handleWithdrawMsg(obj)
            self.performAggregation()
        
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                obj = json.loads(msg)
                self.handleMsg(obj, srcif)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()