#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, select

class Router:

    relations = {}
    sockets = {}
    ports = {}
    routingTable = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
    
    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def addRoutingEntry(self, network, netmask, ASPath, peer, localpref, selfOrigin, origin):
        self.routingTable.append({
            'network': network, 
            'netmask': netmask, 
            'ASPath': ASPath,
            'peer' : peer,
            'localpref' : localpref,
            'selfOrigin' : selfOrigin,
            'origin' : origin})

        print('current routing table--------------')
        print(self.routingTable)
        print('relations-------------------')
        print(self.relations)
    
    def sendUpdates(self, obj, src):

        print('updte msg-----------------------------------')
        print(obj)

        del obj['localpref']
        del obj['origin']
        del obj['selfOrigin']
        obj['ASPath'] = [self.asn] + obj['ASPath']
        
        print('after modifying-----------------------------------')
        print(obj)

        match self.relations[src]:
            case 'cust':
                # send to all neighbors
                for neighbor in self.sockets.keys():
                    if neighbor == src:
                        # don't send the update back to itself
                        continue
                    print(f'!!!!!!!!!!!!!!!!!!!!!!!sending update to neighbor: {neighbor}')
                    print(neighbor)
                    self.send(neighbor, json.dumps({
                        'type': 'update', 
                        'src': self.our_addr(neighbor), 
                        'dst': neighbor, 
                        'msg': obj}))
            case 'prov' | 'peer':
                print('peer or prov')
                for neighbor in self.sockets.keys():
                    if self.relations[neighbor] == 'cust' and neighbor != src:
                        self.send(neighbor, json.dumps({
                            'type': 'update',
                            'src': self.our_addr(neighbor),
                            'dst': neighbor,
                            'msg': obj}))

    # converts '127.0.0.1' to '01111111000000000000000000000001', for example
    def ipToBinStr(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        binquads = [str(bin(quad))[2:].rjust(8, '0') for quad in quads]
        return ''.join(binquads)

    def getNetmaskBits(self, netmask):
        return sum(bin(int(x)).count('1') for x in netmask.split('.'))

    # returns the length of the prefix match, or 0 if they don't match
    def matches(self, destIp, network, netmask):
        # https://stackoverflow.com/questions/38085571/how-use-netaddr-to-convert-subnet-mask-to-cidr-in-python
        netmaskBits = self.getNetmaskBits(netmask)
        return netmaskBits if self.ipToBinStr(destIp)[:netmaskBits] == self.ipToBinStr(network)[:netmaskBits] else 0

    # TODO make this support the other tie-breaking rules
    def getBestMatch(self, ip):
        
        entryMatches = []

        for entry in self.routingTable:
            entryMatches.append((entry, self.matches(ip, entry['network'], entry['netmask'])))

        # filter dictionary such that it only contains entries with the maximum match length
        longestPrefMatch = max([v[1] for v in entryMatches])
        entryMatches = [v[0] for v in entryMatches if v[1] > 0 and v[1] == longestPrefMatch]

        if len(entryMatches) == 0:
            return None
        elif len(entryMatches) == 1:
            return entryMatches[0]['peer']
        else:
            print('into the tie....')
            maxLocalPref = max([v['localpref'] for v in entryMatches])
            entryMatches = [v for v in entryMatches if v['localpref'] == maxLocalPref]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            tempEntryMatches = [v for v in entryMatches if v['selfOrigin'] == True]
            if len(tempEntryMatches) > 0:
                entryMatches = tempEntryMatches
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            shortestASPath = min([len(v['ASPath']) for v in entryMatches])
            entryMatches = [v for v in entryMatches if len(v['ASPath']) == shortestASPath]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            originWeights = {'IGP':2, 'EGP':1, 'UNK':0}
            bestOriginWeight = max([originWeights[v['origin']] for v in entryMatches])
            entryMatches = [v for v in entryMatches if originWeights[v['origin']] == bestOriginWeight]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            return min([v['peer'] for v in entryMatches])
            

    # don't know if this actually works this way
    def getRouterFromIp(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        quads[3] = int(str(quads[3])[0])
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def sendNoRoute(self, src, dst):
        self.send(dst, json.dumps({
            'type': 'no route',
            'src': src,
            'dst': dst,
            'msg': {}}))

    def handleDataMsg(self, obj):
        print('data obj--------------------------')
        print(obj)
        peer = self.getBestMatch(obj['dst'])
        if peer is None:
            self.sendNoRoute(self.our_addr(obj['src']), self.getBestMatch(obj['src']))
        else:
            # TODO ensure legality
            dstRouter = self.getBestMatch(obj['dst'])
            srcRouter = self.getBestMatch(obj['src'])
            print('ip\'s: ', obj['src'], obj['dst'])

            print('routerz:')
            print(dstRouter)
            print(obj['src'])
            print(self.sockets.keys())

            # determine compliance
            if (srcRouter and self.relations[srcRouter] == 'cust') or (dstRouter and self.relations[dstRouter] == 'cust'):
                self.send(peer, json.dumps(obj))
            else:
                self.sendNoRoute(self.our_addr(obj['src']), self.getBestMatch(obj['src']))
    
    def handleUpdateMsg(self, obj):
        print('?????????????????? recieved an update from a router')
        # 1 TODO save a copy
        # 2 - add to routing table
        self.addRoutingEntry(obj['msg']['network'], obj['msg']['netmask'], obj['msg']['ASPath'], 
        obj['src'], obj['msg']['localpref'], obj['msg']['selfOrigin'], obj['msg']['origin'])
        # 3 - send copies to approproate neighbors
        self.sendUpdates(obj['msg'], obj['src'])

    def handleDumpMsg(self, obj):
        print('dump msg: [[[[[[[[[[[[[[]]]]]]]]]]]]]]')
        print(obj)
        self.send(obj['src'], json.dumps({
            'type': 'table',
            'src': obj['dst'],
            'dst': obj['src'],
            'msg': self.routingTable}))

    def handleWithdrawMsg(self, obj):
        # TODO save copy of withdraw message

        print('withdraw msg---------------')
        print(obj)
        print('pre delete routing table')
        print(self.routingTable)

        for entryToDel in obj['msg']:
            for entry in self.routingTable:
                if (entryToDel['network'] == entry['network']
                    and entryToDel['netmask'] == entry['netmask']
                        and entry['peer'] == obj['src']):
                    self.routingTable.remove(entry)

        print('post delete routing table')
        print(self.routingTable)

        match self.relations[obj['src']]:
            case 'cust':
                # send to all neighbors
                for neighbor in self.sockets.keys():
                    if neighbor == obj['src']:
                        # don't send the update back to itself
                        continue
                    self.send(neighbor, json.dumps({
                        'type': 'withdraw', 
                        'src': self.our_addr(neighbor), 
                        'dst': neighbor, 
                        'msg': obj['msg']}))
            case 'prov' | 'peer':
                # send to only customers
                for neighbor in self.sockets.keys():
                    if self.relations[neighbor] == 'cust' and neighbor != obj['src']:
                        # don't send the update back to itself
                        self.send(neighbor, json.dumps({
                            'type': 'withdraw',
                            'src': self.our_addr(neighbor),
                            'dst': neighbor,
                            'msg': obj['msg']}))
                    

    def handleMsg(self, obj):
        print('handling msg: ')
        print(obj)
        match obj['type']:
            case 'update':
                self.handleUpdateMsg(obj)
            case 'data':
                self.handleDataMsg(obj)
            case 'dump':
                self.handleDumpMsg(obj)
            case 'withdraw':
                self.handleWithdrawMsg(obj)

    def adjacent(self, network1, network2):
        if network1['netmask'] != network2['netmask']:
            return False
        
        netmaskBits = self.getNetmaskBits(network1['netmask'])

        network1str = self.ipToBinStr(network1['network'])
        network2str = self.ipToBinStr(network2['network'])

        return (network1str[:netmaskBits-1] == network2str[:netmaskBits-1]
                and network1str[:netmaskBits-1] != network2str[:netmaskBits-1])

    def canBeAggregated(self, network1, network2):
        return (self.adjacent(network1, network2) and
                network1['peer'] == network2['peer'] and
                network1['localpref'] == network2['localpref'] and
                network1['origin'] == network2['origin'] and
                network1['ASPath'] == network2['ASPath'] and
                network1['selfOrigin'] == network2['selfOrigin'])

    def aggregateEntries(self, network1, network2, netmaskLen):

        netmaskLen = self.getNetmaskBits(network1['netmask'])
        newNetworkStr = self.ipToBinStr(network1['network'])[:netmaskLen - 1].ljust(32, '0')
        newNetMaskBits = netmaskLen - 1

        quads = [str(int(newNetworkStr[i:i+8], 2)) for i in range(0, len(newNetworkStr), 8)]
        newNetwork = '.'.join(quads)

        newNetMaskStr = '1' * newNetMaskBits
        newNetMaskStr = newNetMaskStr.ljust(32, '0')

        maskQuads = [str(int(newNetMaskStr[i:i+8], 2)) for i in range(0, len(newNetMaskStr), 8)]
        newNetmask = '.'.join(maskQuads)
        
        return {'network': newNetwork,
                'netmask': newNetmask,
                'peer': network1['peer'],
                'origin': network1['origin'],
                'selfOrigin': network1['selfOrigin'],
                'ASPath': network1['ASPath'],
                'localpref': network1['localpref']}
    
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                obj = json.loads(msg)
                print(obj)
                self.handleMsg(obj)
                #print("Received message '%s' from %s" % (msg, srcif))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()