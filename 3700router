#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, select

class Router:

    relations = {}
    sockets = {}
    ports = {}
    routingTable = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
    
    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def addRoutingEntry(self, network, netmask, ASPath, peer, localpref, selfOrigin, origin):
        self.routingTable.append({
            'network': network, 
            'netmask': netmask, 
            'ASPath': ASPath,
            'peer' : peer,
            'localpref' : localpref,
            'selfOrigin' : selfOrigin,
            'origin' : origin})

        print('current routing table--------------')
        print(self.routingTable)
        print('relations-------------------')
        print(self.relations)
    
    def sendUpdates(self, obj, src):

        print('updte msg-----------------------------------')
        print(obj)

        del obj['localpref']
        del obj['origin']
        del obj['selfOrigin']
        obj['ASPath'] = [self.asn] + obj['ASPath']
        
        print('after modifying-----------------------------------')
        print(obj)

        match self.relations[src]:
            case 'cust':
                # send to all neighbors
                for neighbor in self.sockets.keys():
                    if neighbor == src:
                        # don't send the update back to itself
                        continue
                    print(f'!!!!!!!!!!!!!!!!!!!!!!!sending update to neighbor: {neighbor}')
                    print(neighbor)
                    self.send(neighbor, json.dumps({
                        'type': 'update', 
                        'src': self.our_addr(neighbor), 
                        'dst': neighbor, 
                        'msg': obj}))
            case 'prov' | 'peer':
                # send to only customers
                pass

    # converts '127.0.0.1' to '01111111000000000000000000000001', for example
    def ipToBinStr(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        binquads = [str(bin(quad))[2:].rjust(8, '0') for quad in quads]
        return ''.join(binquads)

    # returns the length of the prefix match, or 0 if they don't match
    def matches(self, destIp, network, netmask):
        print('matches: ' + destIp, netmask, netmask)
        # https://stackoverflow.com/questions/38085571/how-use-netaddr-to-convert-subnet-mask-to-cidr-in-python
        netmaskBits = sum(bin(int(x)).count('1') for x in netmask.split('.'))
        ans = netmaskBits if self.ipToBinStr(destIp)[:netmaskBits] == self.ipToBinStr(network)[:netmaskBits] else 0
        print(ans)
        return ans

    # TODO make this support the other tie-breaking rules
    def getBestMatch(self, ip):

        if '10.' in ip:
            print('xyz')

        bestMatch = {}
        bestMatchLen = 0

        entryDict = {}
        entryMatches = []
        
        print(f'rlen: {len(self.routingTable)}')
        for entry in self.routingTable:
            print('foo')
            entryDict[entry['peer']] = (entry, self.matches(ip, entry['network'], entry['netmask']))
            entryMatches.append((entry, self.matches(ip, entry['network'], entry['netmask'])))

        print(f'elen: {len(entryMatches)}')
        
        # filter dictionary such that it only contains entries with the maximum match length
        print(f'matchlens : {[v[1] for v in entryDict.values()]}')
        longestPrefMatch = max([v[1] for v in entryMatches])
        entryMatches = [v[0] for v in entryMatches if v[1] > 0 and v[1] == longestPrefMatch]

        print('this is the filtered dictionary:')
        print(entryMatches)

        if len(entryMatches) == 0:
            print(f'yoqength 0, ip: {ip}, match: {longestPrefMatch}')
            print(self.routingTable)
            print(f'entry len: {len(entryMatches)}, routlen: {len(self.routingTable)}')
            print(self.matches(ip, '11.0.0.0', '255.0.0.0'))

#           00001011 00000000 00000000 00000000
#           00001011 00000000 00000000 00011001

            return None
        elif len(entryMatches) == 1:
            return entryMatches[0]['peer']
        else:
            print('into the tie....')
            maxLocalPref = max([v['localpref'] for v in entryMatches])
            entryMatches = [v for v in entryMatches if v['localpref'] == maxLocalPref]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            entryMatches = [v for v in entryMatches if v['selfOrigin'] == True]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            shortestASPath = min([len(v['ASPath']) for v in entryMatches])
            entryMatches = [v for v in entryMatches if len(v['ASPath']) == shortestASPath]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            originWeights = {'IGP':2, 'EGP':1, 'UNK':0}
            bestOriginWeight = max([originWeights[v['origin']] for v in entryMatches])
            entryMatches = [v for v in entryMatches if originWeights(v['origin']) == bestOriginWeight]
            if len(entryMatches) == 1:
                return entryMatches[0]['peer']
            return min([v['peer'] for v in entryMatches])
            
            print('post localpref filtering-----------------------')
            print(entryMatches)
            

        print('printing routingggggg table')
        print(self.routingTable)
        print('printing match lengths')
        print(entryDict)
        print('printing filtered match lengths')
        print(entryMatches)

        '''
        for entry in self.routingTable:
            matchLen = self.matches(ip, entry['network'], entry['netmask'])
            if matchLen > bestMatchLen:
                bestMatchLen = matchLen
                bestMatch = entry
        return bestMatch if bestMatchLen > 0 else None
        '''

    # don't know if this actually works this way
    def getRouterFromIp(self, ip):
        quads = list(int(qdn) for qdn in ip.split('.'))
        quads[3] = int(str(quads[3])[0])
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def handleDataMsg(self, obj):
        print('data obj--------------------------')
        print(obj)
        peer = self.getBestMatch(obj['dst'])
        if peer is None:
            pass
            # TODO send a no route message back
        else:
            # TODO ensure legality
            srcRouter = self.getRouterFromIp(obj['src'])
            dstRouter = self.getRouterFromIp(obj['dst'])
            print(self.relations)

            # TODO figure out how to derive source/dest router from source/dest ips so we can ensure legality
            if True: #self.relations[srcRouter] == 'cust' or self.relations[dstRouter] == 'cust':
                print('i\'m sending data woooooooooooooooooo')
                self.send(peer, json.dumps(obj))
            else:
                pass
                # not making money, so drop!
                # TODO send a no route message back
    
    def handleUpdateMsg(self, obj):
        print('?????????????????? recieved an update from a router')
        # 1 TODO save a copy
        # 2 - add to routing table
        self.addRoutingEntry(obj['msg']['network'], obj['msg']['netmask'], obj['msg']['ASPath'], 
        obj['src'], obj['msg']['localpref'], obj['msg']['selfOrigin'], obj['msg']['origin'])
        # 3 - send copies to approproate neighbors
        self.sendUpdates(obj['msg'], obj['src'])

    def handleDumpMsg(self, obj):
        print('dump msg: [[[[[[[[[[[[[[]]]]]]]]]]]]]]')
        print(obj)
        self.send(obj['src'], json.dumps({
            'type': 'table',
            'src': obj['dst'],
            'dst': obj['src'],
            'msg': self.routingTable}))

    def handleMsg(self, obj):
        print('handling msg: ')
        print(obj)
        match obj['type']:
            case 'update':
                self.handleUpdateMsg(obj)
            case 'data':
                self.handleDataMsg(obj)
            case 'dump':
                self.handleDumpMsg(obj)
    
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                obj = json.loads(msg)
                print(obj)
                self.handleMsg(obj)
                #print("Received message '%s' from %s" % (msg, srcif))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()